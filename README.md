# Multicode V3

## Обзор
Multicode V3 — редактор исходного кода, который объединяет текстовое и визуальное представления программ. Пользователь может свободно переключаться между режимами и работать с дополнительными метаданными без изменения логики кода.

## Архитектура
- **Backend (Rust, Tauri):** парсинг файлов через tree-sitter, хранение и обработка метаданных, управление плагинами.
- **Frontend (Vite, JavaScript):** интерфейс с Monaco‑редактором и canvas‑основанным редактором блоков.
- **Связь компонентов:** локальный WebSocket‑сервер синхронизирует состояния между частями приложения.

## Ключевые возможности
- Переключение между текстовым и визуальным режимами.
- Сохранение метаданных в комментариях к исходному коду.
- Поддержка плагинов для расширения набора блоков.
- Работа с несколькими языками программирования.

## Структура метакомментариев
Служебная информация сохраняется в комментариях `@VISUAL_META` в формате JSON. Общая структура:
```json
{
  "id": "уникальный идентификатор блока",
  "x": координатаX,
  "y": координатаY,
  "note": "произвольный текст"
}
```
Комментарий не влияет на выполнение программы и может быть удалён при экспорте.

## Инструкции по запуску и сборке
1. Установите Rust, Node.js и [Tauri CLI](https://tauri.app).
2. Установите зависимости и выполните тесты:
   ```
   cd frontend && npm install && npm test
   cd ../backend && cargo test
   ```
3. Запуск режима разработки:
   ```
   cd frontend
   npm run tauri dev
   ```
4. Сборка десктопного приложения:
   ```
   cd frontend
   npm run tauri build
   ```
   Скомпилированные бинарные файлы появятся в `frontend/src-tauri/target/release`.

## Добавление модулей
Плагины позволяют добавлять новые блоки и функциональность. Минимальный
пример расположен в [examples/plugins](examples/plugins) и имеет следующую
структуру:

```
examples/plugins/
├── my_plugin.rs     — backend-часть
├── my-block.js      — frontend-часть
└── README.md
```

### Пошаговое создание плагина
1. Скопируйте структуру каталога из примера или создайте аналогичный
   набор файлов.
2. **Backend:** реализуйте трейт [`Plugin`](backend/src/plugins/mod.rs),
   возвращающий `BlockDescriptor` с описанием нового блока.
3. Подключите плагин на серверной стороне и соберите проект.
4. **Frontend:** реализуйте модуль с функцией `register({ Block,
   registerBlock })`, в которой объявите класс блока и вызовете
   `registerBlock`.
5. Передайте путь к модулю в `loadBlockPlugins`, например
   `loadBlockPlugins(['./my-block.js'])`.

### Тестирование плагинов
- Запускайте `cargo test` в каталоге backend для проверки серверной части.
- Выполняйте `npm test` в каталоге frontend, чтобы убедиться в корректной
  работе визуальной компоненты.
- Для интеграционной проверки запускайте приложение командой
  `npm run tauri dev` и убедитесь, что новый блок отображается без ошибок.

## Словарь
- **Блок:** визуальное представление участка кода.
- **Метакомментарий:** комментарий `@VISUAL_META` с координатами и прочими данными.
- **Плагин:** набор расширений для добавления новых блоков.

## Структура репозитория
- `backend` — серверная часть на Rust.
- `frontend` — интерфейс и клиентская логика.
- `plugins` — встроенные плагины и механизм их загрузки.
- `examples` — примеры плагинов и использования.
- `logs` — временные файлы и журналы.

## Лицензия
Проект распространяется по лицензии MIT. Полный текст приведён в файле [LICENSE](LICENSE).

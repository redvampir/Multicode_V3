# Поддерживающие системы Neira

## Навигация
- [Обзор Нейры](README.md)
- [Узлы действий](action-nodes.md)
- [Узлы анализа](analysis-nodes.md)
- [Узлы памяти](memory-nodes.md)
- [Архитектура анализа](analysis-architecture.md)
- [Поддерживающие системы](support-systems.md)
- [Личность Нейры](personality.md)
- [Шаблон узла](node-template.md)
- [Политика источников](source-policy.md)

## Оглавление
- [InteractionHub](#interactionhub)
- [TaskScheduler](#taskscheduler)
- [Feedback Aggregator](#feedback-aggregator)
- [Рабочая память](#рабочая-память)
- [Модуль эмоций](#модуль-эмоций)
- [Диалоговая логика](#диалоговая-логика)
- [Модуль личности](#модуль-личности)
- [Игровой модуль](#игровой-модуль)
- [Скептический модуль](#скептический-модуль)
- [Уведомления о прогрессе](#уведомления-о-прогрессе)


## InteractionHub
Единый оркестратор, через который проходят все запросы пользователя. Он регистрирует события, проверяет права доступа и направляет обращения к нужным узлам. InteractionHub агрегирует ответы ActionNode и MemoryNode, связывая их с исходным контекстом и формируя итоговый результат.

```rust
struct InteractionHub {
    sessions: HashMap<SessionId, Context>,
    log: EventLog,
}
```

### Последовательность вызовов
1. `receive(request)` — фиксирует обращение и создаёт `request_id`.
2. `authorize(context)` — проверяет права пользователя и окружение.
3. `dispatch(request)` — направляет запрос в соответствующие `ActionNode` и `MemoryNode`.
4. Узлы возвращают промежуточные ответы и события.
5. `aggregate(results)` — объединяет ответы узлов с исходным контекстом.
6. `respond(aggregate)` — формирует итоговый ответ и записывает его в журнал.

### Формат ответа
InteractionHub возвращает объект с итоговым результатом и идентификатором запроса:

```json
{
  "request_id": "<uuid>",
  "input": "<исходный текст>",
  "output": "<финальный ответ>",
  "reasoning_snippet": "<краткое объяснение шага>",
  "errors": null
}
```

#### Пример

```json
{
  "request_id": "f65c3b9a-9e2a-4c39-8e27-1f523b9a8b5b",
  "input": "Где находится Эйфелева башня?",
  "output": "Эйфелева башня расположена в Париже, Франция.",
  "reasoning_snippet": "Проверяю факты о достопримечательностях"
}
```

## TaskScheduler
`TaskScheduler` распределяет задачи по очередям `fast`, `standard` и `long` в зависимости от оценки длительности. AnalysisNode передаёт задачу в соответствующий канал, а Scheduler отвечает за параллелизм и контроль квот, учитывая параметры `priority`, `max_iterations` и `time_slice_ms` каждого узла (см. [«Планировщик и лимиты итераций»](README.md#планировщик-и-лимиты-итераций)).

```toml
[scheduler]
fast = 60_000          # 1 минута
standard = 1_800_000   # 30 минут
long = 28_800_000      # 8 часов
global_time_budget = 86_400_000 # 24 часа на весь запрос
cancel_token_poll_ms = 500      # проверка отмены раз в 0.5 с
checkpoint_interval_ms = 1_000  # сохранение состояния раз в 1 с
```

### Лимиты ресурсов

| Ресурс | Лимит |
|--------|-------|
| CPU    | 2 ядра |
| RAM    | 4 ГБ |
| GPU    | 0 |

Значения берутся из конфигурации планировщика и при необходимости могут масштабироваться.

**Рекомендации по расширению:** 32 ГБ RAM и 8–12 ядер CPU.

- Приоритет задач определяется методом `get_priority()` узлов памяти, который учитывает `QualityMetrics` и `UsageStats`.
- Scheduler периодически пересчитывает приоритеты на основе агрегированной статистики и передаёт обновлённые значения связанным AnalysisNode.

### global_time_budget, cancel_token и checkpointing

Планировщик отслеживает суммарный `global_time_budget` и при превышении лимита
сигнализирует об отмене через `cancel_token`. Узлы обязаны регулярно проверять
этот токен и при остановке сохранять прогресс в чекпоинты. Контрольные точки
(`checkpointing`) позволяют возобновить выполнение задачи после перезапуска или
повторного планирования.

## Feedback Aggregator
Агрегатор собирает сигналы от пользователей и автотестов. Он ведёт единый поток обратной связи, влияющий на приоритеты обслуживания узлов памяти.

```rust
struct FeedbackEntry {
    node_id: NodeId,
    source: FeedbackSource,
    metric: String,
    score: f32,
    timestamp: DateTime<Utc>,
}
```

Поток работы:

1. событие фиксируется как `FeedbackEntry`;
2. агрегатор обновляет `QualityMetrics` и `UsageStats` соответствующего узла памяти;
3. планировщик вызывает `update_priority()` узлов памяти на основании обновлённой статистики.

Подробнее см. разделы [analysis-nodes](analysis-nodes.md) и [memory-nodes](memory-nodes.md).

## Система пакетов
Пакеты позволяют расширять Нейру новыми возможностями без изменения ядра. Каждый пакет
содержит метаданные и исходный код модуля.

```text
draw/
├── package.toml
├── README.md
└── src/
    └── lib.rs
```

В файле `package.toml` описываются имя, версия и точка входа:

```toml
name = "draw"
version = "0.1.0"
entry = "src/lib.rs"
```

### package.manifest
Файл `package.manifest` определяет права пакета. В секции `permissions`
указываются четыре базовых типа разрешений:

- `fs` — доступ к файловой системе;
- `net` — разрешённые сетевые адреса;
- `cpu` — допустимая доля времени процессора;
- `mem` — лимит оперативной памяти.

```toml
# package.manifest
[permissions]
fs = ["read:/data", "write:/tmp"]
net = ["https://api.example.com"]
cpu = 0.5
mem = "128MB"
```
Пример такого файла включён в репозиторий: [`examples/package.manifest`](../../examples/package.manifest).

### Управление пакетами
Пакеты устанавливаются и обновляются через CLI:

```bash
neira pkg install draw   # установка
neira pkg update draw    # обновление
neira pkg remove draw    # удаление
```

### Проверка подписи и откат
Перед запуском пакета рекомендуется проверить его подпись:

```bash
neira pkg verify draw    # проверка подписи
```

При необходимости можно откатить пакет к предыдущей версии:

```bash
neira pkg rollback draw --version 0.1.0
```

### Минимальный пример
Простейший пакет может предоставлять модуль рисования:

```rust
// src/lib.rs
pub fn init() {
    canvas::line(Point::new(0, 0), Point::new(10, 10));
}
```

## Рабочая память
Временное хранилище актуального контекста. Содержит последние сообщения, переменные запроса и результаты промежуточных вычислений. Записи автоматически вытесняются по таймеру или при переполнении лимита.

```rust
struct WorkingMemory {
    messages: Vec<Message>,
    variables: HashMap<String, Value>,
    ttl: Duration,
}
```

### Методы доступа
- `store(context)` — добавляет сообщения и переменные в память, обновляя таймер `ttl`;
- `retrieve(key)` — возвращает сохранённое значение или сообщение по ключу;
- `evict(expired)` — удаляет записи, у которых `ttl` истёк или превышен лимит памяти.

### Пример состояния
```json
{
  "messages": [
    { "role": "user", "content": "Привет" },
    { "role": "assistant", "content": "Чем могу помочь?" }
  ],
  "variables": { "topic": "travel", "step": 2 },
  "ttl": 600000
}
```

## Модуль эмоций
Следит за тоном диалога и внутренним состоянием системы. Положительные сигналы усиливают инициативность, негативные — вызывают осторожность и запрос на уточнение. Эмоции не влияют на логику вывода, но помогают выбирать стиль ответа.

## Диалоговая логика
Определяет намерение пользователя и выбирает стиль ответа. Также решает, когда активировать образ Нейры, а когда переключиться на сухой режим. Детали по доступным логам и объяснениям в разных режимах см. в разделе [«Логи и объяснения по режимам»](personality.md#логи-и-объяснения-по-режимам).

## Модуль личности
Хранит характеристики персонажа и набор устойчивых фраз. Может быть временно отключён для экономии ресурсов или по запросу пользователя.

## Игровой модуль
Использует игровые сценарии как способ обучения и мотивации. Во время игр анализируются сюжет, актёрская работа и нестандартные ситуации, формируя новые узлы анализа.

## Скептический модуль
Добавляет уточняющие вопросы и проверку фактов. В сухом режиме может отключаться для ускорения работы.

## Уведомления о прогрессе
Для задач класса `standard` и `long` InteractionHub отправляет промежуточные сообщения о ходе выполнения. Scheduler выдаёт процент готовности, который отображается пользователю. После завершения задача помечается в журнале и из рабочей памяти удаляются временные записи.

### Формат прогресса
Каждое уведомление содержит краткую информацию о текущем шаге:

```json
{
  "status": "running",
  "step": "fetch_memory",
  "reasoning_snippet": "извлекаю факты о Париже"
}
```

Поле `status` показывает состояние задачи, `step` описывает текущий этап, а `reasoning_snippet` содержит короткий фрагмент цепочки рассуждений.

## Схемы

JSON‑схемы расположены в каталоге [../../schemas](../../schemas). При несовместимых изменениях повышайте версию: `1.0.0` → `1.1.0`.

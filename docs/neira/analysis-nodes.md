# Узлы анализа (Analysis Nodes)

## Правила оформления
- Используется нейтральный технический стиль.
- Термины применяются последовательно и в единой форме.
- При расширении документа следует сохранять указанный стиль и терминологическое единство.

### Шаблон раздела

````markdown
#### <Название подтипа>

- **Назначение:** краткое описание роли подтипа.
- **Пример:**
```json
{
  "id": "example.id",
  "type": "<Название>"
}
```
- **Метаданные:**
```yaml
schema: "1.0"
source: "https://example.org"
```
````

## Оглавление
- [1. Базовый интерфейс узла](#1-базовый-интерфейс-узла)
  - [Сериализация и версионирование](#сериализация-и-версионирование)
- [2. Иерархия и назначение подтипов](#2-иерархия-и-назначение-подтипов)
- [3. Взаимодействие узлов анализа с подсистемами](#3-взаимодействие-узлов-анализа-с-подсистемами)
- [4. Фильтрация и весовка источников](#4-фильтрация-и-весовка-источников)
- [5. Pipeline создания новых подтипов](#5-pipeline-создания-новых-подтипов)
- [6. Приоритеты начального обучения](#6-приоритеты-начального-обучения)
- [7. Автономное расширение](#7-автономное-расширение)
- [8. Управление узлами через редактор](#8-управление-узлами-через-редактор)
- [9. Редактор и пометка ошибок](#9-редактор-и-пометка-ошибок)
- [10. Итоговая документация](#10-итоговая-документация)
- [11. Счётчик ревизий и критерий улучшения](#11-счётчик-ревизий-и-критерий-улучшения)
- [12. Стратегия многоязычности](#12-стратегия-многоязычности)
- [13. Перспективные и устойчивые технологии](#13-перспективные-и-устойчивые-технологии)
- [14. A/B‑тестирование и откат](#14-ab-тестирование-и-откат)

## 1. Базовый интерфейс узла
- **Интерфейс:** `AnalysisNode`
- **Свойства:** идентификатор, тип, степень достоверности, связи.
- **Методы:** `analyze()`, `explain()`, `updateContext()` и т. п.
- **Назначение:** единый контракт для всех типов узлов, обеспечивающий расширяемость и полиморфизм.
### Сериализация и версионирование

Узлы сохраняются и передаются в формате JSON или YAML по следующей схеме:

```yaml
id: string                 # обязательный
type: string               # обязательный
confidence: number         # 0..1, опционально
links:                     # опционально
  - string
status: string             # обязательный (draft|active|deprecated|error)
metadata:                  # опционально
  schema: "1.0"            # версия схемы
```

Версионирование определяется полем `metadata.schema` и следует [Semantic Versioning](https://semver.org/). `MAJOR` меняется при несовместимых изменениях, `MINOR` — при добавлении опциональных полей, `PATCH` — при исправлении описаний.

**Обязательные поля:** `id`, `type`, `status`, `metadata.schema`.
**Опциональные поля:** `confidence`, `links`, остальные элементы `metadata`.

#### Пример `ProgrammingSyntaxNode`

```json
{
  "id": "prog.syntax.python.for",
  "type": "ProgrammingSyntaxNode",
  "confidence": 0.95,
  "links": ["prog.syntax.iteration"],
  "status": "active",
  "metadata": {
    "schema": "1.0",
    "language": "Python",
    "example": "for i in range(10): print(i)"
  }
}
```

## 2. Иерархия и назначение подтипов

| Подтип | Назначение |
| --- | --- |
| Синтаксические | Разбор структуры языка, токенизация, грамматика. |
| Семантические | Определение смысловых связей, контекста и онтологических отношений. |
| Доменные | Работа с отраслевыми знаниями (медицина, программирование и т. д.). |
| Интеграционные | Сбор и объединение результатов других узлов, построение итоговых планов и ответов. |
| Метакогнитивные | Самоанализ, корректировка ошибок, оптимизация алгоритмов. |
| Целевые (Task/Goal) | Расчленение запросов на задачи, выбор действий для достижения целей. |
| Точные (Deterministic) | Верификация утверждений, проверяемые расчёты, приоритет достоверных данных. |
| Гипотетические | Работа в условиях недостатка данных: уточнения, оценка надежности источников, предупреждения о низкой точности. |
| Эмоционального анализа | Определение эмоционального состояния пользователя и аккуратная реакция на негатив. |
| Обман/Сокрытие (Deception) | Режим, где сообщается частичная или альтернативная информация в ситуациях требования скрытия деталей. |
| Скептические | Проверка достоверности спорных источников, фильтрация псевдонаучных утверждений. |
| Логических ловушек | Распознавание и нейтрализация когнитивных и риторических заблуждений (ошибка большинства, «ошибка выжившего» и др.). |

**Подтипы «Метакогнитивные» дополнительно включают:**
- Ошибка‑анализ: локализация и классификация сбоев.
- Логика опыта: использование заранее заложенных философских и эвристических размышлений.

## 3. Взаимодействие узлов анализа с подсистемами

### Единый оркестратор (InteractionHub)
- Все запросы пользователя проходят через оркестратор.
- AnalysisNode создаёт контекст запроса и обращается к MemoryNode или ActionNode только через InteractionHub, что обеспечивает проверку прав доступа и логирование.
- Ответы узлов агрегируются обратно в оркестратор, который связывает цепочку Analysis⇄Memory⇄Action, вычисляет степень уверенности и формирует итог.

### Планировщик задач (TaskScheduler)
- Каждый запрос классифицируется по ожидаемой продолжительности и выделяемым ресурсам:
  - **`fast`** — короткие операции, которые завершаются менее чем за минуту и выполняются синхронно.
  - **`standard`** — типовые задачи до 30 минут; пользователь может получать промежуточные уведомления о ходе выполнения.
  - **`long`** — ресурсоёмкие вычисления до 8 часов, обрабатываются асинхронно с периодическими отчётами о прогрессе.
- AnalysisNode оценивает требуемое время и отправляет задачу в соответствующую очередь.
- Для долгих задач система возвращает пользователю идентификатор операции и периодически уведомляет о прогрессе.

#### Пример обработки долгого запроса
1. Пользователь отправляет сложный запрос.
2. InteractionHub регистрирует его и передаёт в очередь `long`.
3. AnalysisNode делит задачу на подэтапы, обращаясь к MemoryNode и вызывая ActionNode.
4. По мере выполнения TaskScheduler сообщает оркестратору о статусе, а тот — пользователю.
5. После завершения результаты агрегируются в InteractionHub и возвращаются пользователю.

Дополнительные детали см. в разделе [поддерживающих систем](support-systems.md).

## 4. Фильтрация и весовка источников
- **Фильтрация источников:** отдельные списки доверенных книг, статей и сайтов; GitHub‑репозитории только с релизами `v1.0+`.
- **Система весов:** каждому источнику назначается рейтинг надёжности на основе факта публикации, цитируемости и согласованности с уже проверенными знаниями.
- **Квота на «воду»:** фиксируется доля описательных блоков и формализованных правил; узлы отклоняют материал, где структурированных знаний недостаточно.

### Механизм рейтингов и пороги достоверности
- Источники получают числовой рейтинг в диапазоне `0..1`.
- Оценка формируется из типа публикации, цитируемости, истории ошибок и совпадения с уже подтверждёнными узлами.
- Факты автоматически принимаются при рейтинге `≥ 0.7`; значения `0.4–0.7` помечаются как гипотезы и отправляются на дополнительную проверку, ниже `0.4` — отклоняются.
- Рейтинг хранится вместе с узлом; при падении ниже рабочего порога узел помечается для пересмотра.
- Порог может корректироваться в зависимости от контекста задачи и указаний редактора.

### Контроль качества и защита от шума
- Согласованность между источниками: новый факт принимается только при подтверждении двумя независимыми источниками.
- Аудит ошибок: при обнаружении несоответствий узел формирует заявку на пересмотр источников.
- Регулярная переоценка: периодические задачи проверяют популярные узлы на предмет устаревания.

Дополнительные правила отбора и лицензирования изложены в [политике источников](source-policy.md).

## 5. Pipeline создания новых подтипов

**Этапы конвейера:** Ингестор → Дедупликация → Шаблонизатор → Review → Регистрация.

1. **Ингестор** собирает данные из внешних источников (API, репозитории, публикации) и приводит их к единому формату.
2. **Дедупликация** сравнивает поступившие факты с текущей базой; дубликаты удаляются, а конфликтующие значения помечаются для ручной проверки.
3. **Шаблонизатор** формирует из очищенных данных черновой `NodeTemplate`, заполняя описание, связи и исходные рейтинги.
4. **Review**: эксперт просматривает шаблон, при необходимости корректирует формулировки и утверждает или отклоняет предложение.
5. **Регистрация** заносит подтверждённый узел в реестр; идентификатор и метаданные сохраняются для дальнейшего обучения.

Пример записи нового узла с метаданными `source`, `timestamp` и `reviewer`:

```json
{
  "id": "math.integral.rule.v1",
  "type": "deterministic",
  "source": "https://example.org/calculus",
  "timestamp": "2024-05-10T12:00:00Z",
  "reviewer": "editor@example.com"
}
```

## 6. Приоритеты начального обучения
- **Языки общения:** отдельные узлы для синтаксики и семантики русского и английского языков; их развитие влияет на качество остальных подтипов.
- **Языки программирования:** подтипы для Rust (синтаксис, идиомы, оптимизация) и компонентов стэка Multicode.
- **Доменные ветки:** веб‑, мобильная и десктопная разработка описываются как независимые ветви знаний.
- **Обучение через проекты:** анализируются только релизные ветки репозиториев, фиксируются шаблоны «как делать правильно» и отмечаются анти‑паттерны.
- **Commit-by-commit исследование:** история изменений изучается пошагово, чтобы понять логику развития кода. Процесс включает:
  1. просмотр последовательности коммитов от ранних версий к текущим;
  2. сопоставление сообщений коммитов с изменениями в коде;
  3. фиксацию причин исправлений и эволюции архитектуры;
  4. выявление повторяющихся паттернов и областей риска.
  Такой анализ позволяет увидеть мотивы решений команды и выделить участки, требующие углублённого чтения.

## 7. Автономное расширение
- При обнаружении нового понятия узел инициирует диалог: «Найдено неизвестное правило/техника, добавить новый подтип?».
- После подтверждения запускается pipeline, и создаётся новый `AnalysisNode` с меткой происхождения (source, timestamp, reviewer).
- Фабрика узлов автоматически выбирает или порождает нужный подтип на основании контекста и диалога.
- Метаданные происхождения сохраняются для последующего анализа и обучения.

## 8. Управление узлами через редактор
- Редактор отображает рейтинги источников и историю изменений узла.
- Любой узел может быть помечен как ошибочный; система требует указать причину, ссылку на источник и желаемое действие (исправить, удалить, отложить).
- Диалоговое объяснение каждого узла доступно через метод `explain()`.
- Поддерживается версионирование и возможность удаления узлов.
- **Примечание:** разработчик может принудительно удалить узел без ссылки и причины только как крайняя мера.

## 9. Редактор и пометка ошибок
Диалог пометки ошибки включает последовательные запросы:

1. **Причина** — редактор просит описать, что именно неверно в узле.
2. **Ссылка на источник** — требуется указать подтверждающий документ или URL.
3. **Желаемое действие** — предлагается выбрать `fix`, `delete` или `defer`.

Пример диалога:

> Редактор: «Укажите причину ошибки».
> Пользователь: «Неверная формула интегрирования».
> Редактор: «Ссылка на источник?»
> Пользователь: "https://example.org/calc"
> Редактор: «Что сделать с узлом: исправить, удалить или отложить?»
> Пользователь: «исправить»

Пометка сохраняется в структуре `ErrorAnnotation`:

```json
{
  "nodeId": "math.integral.rule.v1",
  "reason": "Неверный коэффициент",
  "source": "https://example.org/calc",
  "action": "fix"
}
```

Принудительное удаление разработчиком фиксируется в журнале, однако запись может не содержать поле `source`.

Каждая `ErrorAnnotation` помещается в очередь переобучения: узлы с действиями `fix` и `delete` пересматриваются при следующем цикле обучения, а `defer` откладывает обработку до появления дополнительных данных.

## 10. Итоговая документация
Предстоит подготовить отдельный документ, описывающий:
- Иерархию узлов и их форматы данных.
- Алгоритмы автономного расширения и согласования.
- API для редактора и взаимодействия с пользователем.
- Примеры новых доменных подтипов и процедур их обучения.

## 11. Счётчик ревизий и критерий улучшения
Каждый узел анализа ведёт счётчик ревизий (`revision`), фиксируя количество попыток пересмотреть ответ. Значение увеличивается после принятия каждой новой версии и позволяет ограничить число итераций.

Порог улучшения `IMPROVEMENT_THRESHOLD` определяет минимальный прирост метрики качества между предыдущей и кандидатной версиями. Если изменение меньше порога (например, менее `0.01`), ревизия прекращается и старая версия сохраняется.

```pseudo
revision = 0
prevScore = initialScore
while revision < MAX_REVISIONS:
    candidate = generateProposal()
    newScore = evaluate(candidate)
    if newScore - prevScore < IMPROVEMENT_THRESHOLD:
        break
    accept(candidate)
    prevScore = newScore
    revision += 1
```

Пользователь может влиять на пределы через диалоговые команды, например:
- `set revisions 5` — ограничить количество пересмотров.
- `set improvement 0.02` — изменить порог `IMPROVEMENT_THRESHOLD`.
- `increase revisions 10` — увеличить лимит до десяти пересмотров.

## 12. Стратегия многоязычности
- **Последовательность внедрения языков:**
  - стартовое развитие на русском;
  - расширение на английский;
  - добавление новых языков по мере накопления данных и подтверждения качества.
- **Паттерны обучения с источниками:**
  - Transfer learning для малоресурсных языков — Kocmi & Bojar (2018) [arXiv:1809.00357](https://arxiv.org/abs/1809.00357);
  - Back-translation — Sennrich et al. (2016) [arXiv:1511.06709](https://arxiv.org/abs/1511.06709);
  - Multilingual embeddings — Mikolov et al. (2013) [arXiv:1309.4168](https://arxiv.org/abs/1309.4168).
- **Механизмы, показавшие хорошие результаты:**
  - Нейросетевые: Transformer-NMT (Vaswani et al., 2017), мультилингвальные модели mBERT/mBART.
  - Классические: статистические системы (Moses), правило-ориентированные переводчики (Apertium), анализаторы ошибок LanguageTool/Hunspell/pymorphy2.
- **Приоритеты внедрения:**
  1. Transformer-NMT + transfer learning;
  2. Back-translation для расширения корпуса;
  3. Интеграция грамматических/морфологических анализаторов;
  4. Использование классических SMT/правило-ориентированных решений как резервного канала.

## 13. Перспективные и устойчивые технологии
- **Scrapy**, **Apache Nutch** — зрелые инструменты веб-ингеста.
- **Apache Kafka**, **RabbitMQ** — очереди сообщений для масштабируемых конвейеров.
- **SimHash**, **MinHash** и другие методы LSH — проверенные алгоритмы дедупликации.
- **Jinja2**, **Handlebars**, **Mustache** — широко используемые шаблонизаторы.
- **Git**, **GitHub**, **GitLab** — инфраструктура ревью и контроля версий.
- **PostgreSQL**, **Neo4j**, **Elasticsearch** — устойчивые хранилища для регистрации и поиска узлов.

## 14. A/B‑тестирование и откат

Экспериментальные версии узлов проверяются через A/B‑тесты. Стабильная версия обслуживает основную часть запросов, а кандидат получает ограниченный трафик до завершения испытаний.

Структура `NodeVersion` фиксирует результаты теста:

```yaml
NodeVersion:
  version: string
  metrics:
    success_rate: float        # доля успешных ответов, 0..1
    performance_gain: float    # ускорение относительно стабильной версии (>1 — быстрее)
    usage_frequency: float     # доля запросов, направленных на эту версию
  rollback_threshold:
    success_rate: float        # минимально допустимое значение
```

### Пример записи результатов

```yaml
test_result:
  baseline: "1.1.0"
  candidate:
    version: "1.2.0-beta"
    metrics:
      success_rate: 0.82
      performance_gain: 1.15
      usage_frequency: 0.35
    rollback_threshold:
      success_rate: 0.85
  decision: "rollback"   # 0.82 < 0.85 → вернуться к стабильной версии
```

### Критерий отката

Возврат на стабильную версию выполняется, если `success_rate` кандидата опускается ниже `rollback_threshold.success_rate` или `performance_gain ≤ 1`. В противном случае кандидат может быть принят как новая стабильная версия.

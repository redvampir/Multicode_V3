# Узлы памяти

## Оглавление
- [Документ «Узлы памяти»](#документ-узлы-памяти)
  - [1. Назначение и общая концепция](#1-назначение-и-общая-концепция)
  - [2. Стандартная структура узла](#2-стандартная-структура-узла)
  - [3. Приоритизация источников](#3-приоритизация-источников)
  - [4. Триггерная предварительная загрузка](#4-триггерная-предварительная-загрузка)
  - [5. Оперативная память (кеш) для контекста](#5-оперативная-память-кеш-для-контекста)
  - [6. Автоматическая пересборка черновиков](#6-автоматическая-пересборка-черновиков)
  - [7. Безопасность и контроль доступа](#7-безопасность-и-контроль-доступа)
- [Дополнение и развитие концепции узлов памяти](#дополнение-и-развитие-концепции-узлов-памяти)
  - [Типология узлов и связь с контекстом](#типология-узлов-и-связь-с-контекстом)
  - [Инкрементальное обогащение черновика](#инкрементальное-обогащение-черновика)
  - [Система “микрорефлексов”](#система-микрорефлексов)
  - [Комбинация top-down и bottom-up](#комбинация-top-down-и-bottom-up)
  - [Контроль объёма и “теснота”](#контроль-объёма-и-теснота)
  - [Интерактивная адаптация](#интерактивная-адаптация)
  - [Лог виртуальных цитат](#лог-виртуальных-цитат)

Этот документ описывает назначение и устройство узлов памяти, а также принципы работы с ними в системе.

Схема автоматического пополнения узлов приведена в [отдельном документе](automatic-population.md).

## Документ «Узлы памяти»

### 1. Назначение и общая концепция
Узлы памяти — это единицы сжатого знания, описывающие понятия, факты, правила и т.д. Они служат точками входа к более подробным данным: внутренним базам (книгам, статьям, дипломным работам, расширенным ответам в чатах), внешним интернет‑ресурсам и другим источникам. Система формирует черновой ответ (или код) на основе ближайших узлов, затем при необходимости дополняет его внутренними и внешними данными.

### 2. Стандартная структура узла
Каждый узел содержит обязательные поля:

- **Идентификатор** — уникальный ID узла. Пример: `node_0001`.
- **Тип** — классификация узла (факт, правило, понятие и т.д.). Пример: `fact`.
- **Краткое описание** — суть узла в одной–двух фразах. Пример: `Закон всемирного тяготения Ньютона`.
- **Метаданные** — ключевые слова, дата обновления, уровень доверия. Пример: `keywords: физика; updated: 2024-02-01; trust: high`.
- **Ссылки** — внутренние или внешние источники. Пример: `[Wikipedia](https://ru.wikipedia.org/wiki/Закон_всемирного_тяготения)`.
- **Приоритет** — числовой показатель важности для выборки. Пример: `0.8`.
- **Версия** — номер редакции узла. Пример: `v1.2`.

### 3. Приоритизация источников
Нейроны памяти — начальная выборка для чернового ответа.

Внутренние базы — детальное уточнение/обогащение.

Внешние ресурсы — при недостаточности собственных данных.

Оценка источников опирается на релевантность, доверие и актуальность.

### 4. Триггерная предварительная загрузка
“Узел действий” анализирует ввод пользователя в реальном времени: при обнаружении слов‑триггеров (например, «биология», «программирование», «Rust») система заранее подгружает связанные узлы памяти, экономя время на последующих этапах.

#### Алгоритм работы узла действий
- отслеживает текстовый поток и выделяет потенциальные темы;
- при обнаружении триггера запрашивает метаданные и связанные узлы;
- сохраняет их в оперативный кеш, чтобы последующие обращения проходили без задержки.

#### Примерные слова‑триггеры
- биология
- программирование
- Rust
- математика
- нейросети

#### Предварительно загружаемые данные
- ближайшие узлы памяти: определения, факты и шаблоны;
- индексы связанных документов и ссылок;
- статистику и ранее использованные ответы.

#### Кеширование
Собранные данные помещаются в оперативный кеш с политикой LRU и метками времени. При повторном запросе тех же триггеров система использует уже загруженные сведения, обновляя их при устаревании.

### 5. Оперативная память (кеш) для контекста

Оперативная память выступает временным буфером между запросом пользователя и постоянными узлами. В ней удерживаются:

- актуальный контекст запроса;
- промежуточные расчёты и знания.

Это позволяет быстро обращаться к уже полученной информации без повторного вычисления.

#### Политика сброса и обновления
Хранилище ограничено по размеру и использует политику *Least Recently Used (LRU)*. Когда кеш переполняется, наименее недавно использованные элементы удаляются, освобождая место для новых данных. При смене темы действуют правила сброса или замещения: содержимое кеша может очищаться целиком либо частично, чтобы новая информация не смешивалась с устаревшей.

#### Синхронизация с постоянными узлами
После завершения работы или по таймеру система просматривает содержимое оперативной памяти. Релевантные изменения сериализуются и передаются в постоянные узлы памяти, а временные данные без необходимости сохранения удаляются.

### 6. Автоматическая пересборка черновиков
Система пересчитывает черновой ответ или код при получении новых данных или изменении контекста.

При пересборке система:

- сохраняет промежуточные версии,
- фиксирует триггеры пересборки,
- ведёт лог изменений для контроля качества.

### 7. Безопасность и контроль доступа
- Фильтрация URL.
- Авторизация.
- Разграничение прав доступа.

Доступны списки доверенных доменов и механизм проверки запросов.

## Дополнение и развитие концепции узлов памяти

### Типология узлов и связь с контекстом
Выделите разные типы узлов памяти — факты, правила, понятия, ссылки и т.п. — чтобы при выборке данных учитывать семантику запроса. Это позволит быстрее находить нужную «гранулу знания» и сокращать объём лишнего контента в ответе.
Например, узлы типа «краткий факт» могут иметь более высокий приоритет для предварительной загрузки, а «подробное описание» — для уточнения ответа.

### Инкрементальное обогащение черновика
Рассмотрите процесс пошагового обогащения чернового ответа:

1. Сначала система генерирует короткий набросок, используя ближайшие узлы памяти.
2. Затем добавляет детализацию, подключаясь к внутренним базам знаний.
3. И только в конце, при необходимости, обращается к внешним ресурсам.
Так можно избежать «перебора» данных и оптимизировать время отклика.

### Система “микрорефлексов”
Помимо ключевых слов триггеров (биология, Rust и т.д.), можно добавить «микрорефлексы» — микро-правила, реагирующие на более узкие паттерны (например, «генетические алгоритмы» или «async/await»). Они запускали бы дополнительные модули поиска, если детектируется субтема.

### Комбинация топ-Down и bottom-Up
В дополнение к централизованному алгоритму поиска полезно внедрить bottom-up подход: узлы, связанные с уже найденными, могут «выступать с инициативой» и предлагать себя для дальнейшей выборки. Это позволяет системе выходить на неожиданные, но релевантные детали.

### Контроль объёма и “теснота”
Важно контролировать, сколько узлов одновременно загружаются в оперативную память. Использование «тесноты» или «охвата» — показатели, сколько узлов относят себя к одной теме и насколько они взаимосвязаны. Если система видит, что охват стал слишком широким, можно автоматически ограничить количество узлов, чтобы не потерять фокус.

### Интерактивная адаптация
Во время обсуждения с пользователем система может отслеживать, какие детали вызывают уточнения или дополнительные вопросы. Эти сигналы могут менять приоритеты: например, если пользователь не удовлетворён поверхностным ответом, система усиливает запрос более подробных и авторитетных источников.

### Лог виртуальных цитат
Чтобы пользователю было понятно, откуда берётся информация, полезно вести лог «виртуальных цитат» — меток, указующих, какие узлы памяти или базы были задействованы. Это повышает прозрачность и помогает выбирать, какие части информации сохранять, обновлять или удалять.

Такой подход позволяет гибко управлять информацией, подгружать лишь необходимое и поддерживать баланс между скоростью, точностью и масштабируемостью.

### Связанные базы знаний
Узлы памяти могут ссылаться на внешние и внутренние хранилища данных. Для интеграции рекомендуется использовать свободно распространяемые решения:

- SQL (PostgreSQL, MySQL/MariaDB, SQLite)
  Доступ: SQL-запросы через драйверы или ORM (psycopg2, SQLAlchemy, Sequelize и т.п.)
- NoSQL (MongoDB, CouchDB)
  Доступ: HTTP/REST или клиентские библиотеки, работающие с документами
- Графовые (Neo4j Community Edition, JanusGraph)
  Доступ: запросы Cypher или Gremlin по Bolt/HTTP
- Векторные (FAISS, Milvus Community)
  Доступ: API поиска по эмбеддингам (Python/REST/gRPC клиенты)

#### Формат ссылок/идентификаторов
Поле ссылок в узле памяти хранит унифицированные URI, указывающие на конкретный объект в базе знаний:

- `sql://{db}/{table}/{primary_key}`
- `nosql://{db}/{collection}/{document_id}`
- `graph://{db}/{label}/{node_id}`
- `vector://{index}/{vector_id}`

Дополнительно допускаются параметры `?version=...&meta=...` для версии и сопутствующих метаданных.

use super::{clear_extensions, register_extension, SyncEngine, SyncExtension, SyncMessage, SyncSettings};
use chrono::Utc;
use multicode_core::meta::{self, VisualMeta, DEFAULT_VERSION};
use multicode_core::parser::Lang;
use std::collections::HashMap;

struct DummyPlugin;

impl SyncExtension for DummyPlugin {
    fn parse(&self, code: &str, _lang: Lang) -> Option<Vec<VisualMeta>> {
        if code.contains("trigger-parse") {
            Some(vec![make_meta("parsed", DEFAULT_VERSION)])
        } else {
            None
        }
    }

    fn generate(&self, _code: &str, meta: &VisualMeta, _lang: Lang) -> Option<String> {
        if meta.id == "generate" {
            Some("// generated by extension".into())
        } else {
            None
        }
    }

    fn resolve(&self, _text: &VisualMeta, visual: &VisualMeta) -> Option<VisualMeta> {
        if visual.id == "resolve" {
            let mut m = visual.clone();
            m.x = 42.0;
            Some(m)
        } else {
            None
        }
    }
}

fn make_meta(id: &str, version: u32) -> VisualMeta {
    VisualMeta {
        version,
        id: id.to_string(),
        x: 0.0,
        y: 0.0,
        tags: Vec::new(),
        links: Vec::new(),
        anchors: Vec::new(),
        tests: Vec::new(),
        extends: None,
        origin: None,
        translations: HashMap::new(),
        ai: None,
        extras: None,
        updated_at: Utc::now(),
    }
}

#[test]
fn parse_with_extensions_overrides_parsing() {
    clear_extensions();
    register_extension(DummyPlugin);
    let mut engine = SyncEngine::new(Lang::Rust, SyncSettings::default());
    let (_code, metas, _diag) = engine
        .handle(SyncMessage::TextChanged("trigger-parse".into(), Lang::Rust))
        .unwrap();
    assert_eq!(metas.len(), 1);
    assert_eq!(metas[0].id, "parsed");
    clear_extensions();
}

#[test]
fn generate_with_extensions_overrides_generation() {
    clear_extensions();
    register_extension(DummyPlugin);
    let mut engine = SyncEngine::new(Lang::Rust, SyncSettings::default());
    let meta = make_meta("generate", DEFAULT_VERSION);
    let (code, metas, _diag) = engine.handle(SyncMessage::VisualChanged(meta)).unwrap();
    assert_eq!(code, "// generated by extension");
    assert_eq!(metas.len(), 1);
    assert_eq!(metas[0].id, "generate");
    clear_extensions();
}

#[test]
fn resolve_with_extensions_overrides_conflict() {
    clear_extensions();
    register_extension(DummyPlugin);
    let mut engine = SyncEngine::new(Lang::Rust, SyncSettings::default());
    let base = make_meta("resolve", DEFAULT_VERSION);
    let code = meta::upsert("", &base, false);
    let _ = engine.handle(SyncMessage::TextChanged(code, Lang::Rust));

    let mut updated = base.clone();
    updated.version += 1;
    updated.x = 1.0;
    let (_code, metas, _diag) = engine.handle(SyncMessage::VisualChanged(updated)).unwrap();
    let resolved = metas.iter().find(|m| m.id == "resolve").unwrap();
    assert_eq!(resolved.x, 42.0);
    clear_extensions();
}

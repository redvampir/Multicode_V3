use serde::{Deserialize, Serialize};
mod comment_detector;
pub mod id_registry;

/// Marker used to identify visual metadata comments in documents.
const MARKER: &str = "@VISUAL_META";

/// Metadata stored inside `@VISUAL_META` comments.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Translations {
    pub ru: Option<String>,
    pub en: Option<String>,
    pub es: Option<String>,
}

/// Additional notes provided by AI.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AiNote {
    /// Optional description generated by AI.
    pub description: Option<String>,
    /// Optional hints helping the user.
    #[serde(default)]
    pub hints: Vec<String>,
}

/// Metadata stored inside `@VISUAL_META` comments.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VisualMeta {
    /// Identifier linking this metadata to AST nodes.
    pub id: String,
    /// X coordinate on the canvas.
    pub x: f64,
    /// Y coordinate on the canvas.
    pub y: f64,
    /// Optional reverse path to the original external file.
    #[serde(default)]
    pub origin: Option<String>,
    /// Optional translations for block labels.
    #[serde(default)]
    pub translations: Translations,
    /// Optional AI-generated note.
    #[serde(default)]
    pub ai: Option<AiNote>,
}

/// Insert or update a visual metadata comment in `content`.
///
/// The comment will be placed at the top of the document if it does not exist.
pub fn upsert(content: &str, meta: &VisualMeta) -> String {
    let marker = format!("<!-- {} ", MARKER);
    let serialized = match serde_json::to_string(meta) {
        Ok(s) => s,
        Err(_) => return content.to_string(),
    };

    let mut out = String::new();
    let mut found = false;
    for line in content.lines() {
        if line.trim_start().starts_with(&marker) {
            if let Some(end_idx) = line.find("-->") {
                let json_part = &line[marker.len()..end_idx].trim();
                if let Ok(existing) = serde_json::from_str::<VisualMeta>(json_part) {
                    if existing.id == meta.id {
                        out.push_str(&format!("{}{} -->\n", marker, serialized));
                        found = true;
                        continue;
                    }
                }
            }
        }
        out.push_str(line);
        out.push('\n');
    }

    if !found {
        out = format!("{}{} -->\n{}", marker, serialized, out);
    }

    out
}

/// Read all visual metadata comments from `content`.
pub fn read_all(content: &str) -> Vec<VisualMeta> {
    id_registry::clear();
    let mut metas = Vec::new();
    for json in comment_detector::extract_json(content) {
        if let Ok(meta) = serde_json::from_str::<VisualMeta>(&json) {
            id_registry::register(meta.clone());
            metas.push(meta);
        }
    }
    metas
}

/// Remove all visual metadata comments from `content`.
pub fn remove_all(content: &str) -> String {
    comment_detector::strip(content)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn upsert_and_read_roundtrip() {
        let meta = VisualMeta {
            id: "1".into(),
            x: 10.0,
            y: 20.0,
            translations: Translations::default(),
            ai: Some(AiNote { description: Some("desc".into()), hints: vec!["hint".into()] }),
        };
        let content = "fn main() {}";
        let updated = upsert(content, &meta);
        assert!(updated.contains(MARKER));
        let metas = read_all(&updated);
        assert_eq!(metas.len(), 1);
        assert_eq!(metas[0].x, 10.0);
        assert_eq!(metas[0].ai.as_ref().unwrap().description.as_deref(), Some("desc"));
    }

    #[test]
    fn remove_all_strips_metadata() {
        let content = format!(
            "line1\n<!-- {} {{\"id\":\"1\"}} -->\nline2\n",
            MARKER
        );
        let cleaned = remove_all(&content);
        assert!(!cleaned.contains(MARKER));
        assert!(cleaned.contains("line1"));
        assert!(cleaned.contains("line2"));
    }
}

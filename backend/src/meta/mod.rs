use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
mod comment_detector;
pub mod id_registry;

/// Marker used to identify visual metadata comments in documents.
const MARKER: &str = "@VISUAL_META";

fn default_version() -> u32 {
    1
}

/// Additional notes provided by AI.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AiNote {
    /// Optional description generated by AI.
    pub description: Option<String>,
    /// Optional hints helping the user.
    #[serde(default)]
    pub hints: Vec<String>,
}

/// Metadata stored inside `@VISUAL_META` comments.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VisualMeta {
    /// Schema version of this metadata.
    #[serde(default = "default_version")]
    pub version: u32,
    /// Identifier linking this metadata to AST nodes.
    pub id: String,
    /// X coordinate on the canvas.
    pub x: f64,
    /// Y coordinate on the canvas.
    pub y: f64,
    /// Optional tags associated with this block.
    #[serde(default)]
    pub tags: Vec<String>,
    /// Optional links to other blocks.
    #[serde(default)]
    pub links: Vec<String>,
    /// Optional reverse path to the original external file.
    #[serde(default)]
    pub origin: Option<String>,
    /// Optional translations for block labels.
    #[serde(default)]
    pub translations: HashMap<String, String>,
    /// Optional AI-generated note.
    #[serde(default)]
    pub ai: Option<AiNote>,
    /// Optional plugin-specific metadata.
    #[serde(default)]
    pub extras: Option<serde_json::Value>,
    /// Timestamp of last update in UTC.
    #[serde(default)]
    pub updated_at: DateTime<Utc>,
}

fn migrate(meta: &mut VisualMeta) {
    if meta.version == 0 {
        meta.version = 1;
    }
}

/// Insert or update a visual metadata comment in `content`.
///
/// The comment will be placed at the top of the document if it does not exist.
pub fn upsert(content: &str, meta: &VisualMeta) -> String {
    let marker = format!("<!-- {} ", MARKER);
    let mut meta = meta.clone();
    meta.updated_at = Utc::now();
    let serialized = match serde_json::to_string(&meta) {
        Ok(s) => s,
        Err(_) => return content.to_string(),
    };

    let mut out = String::new();
    let mut found = false;
    for line in content.lines() {
        if line.trim_start().starts_with(&marker) {
            if let Some(end_idx) = line.find("-->") {
                let json_part = &line[marker.len()..end_idx].trim();
                if let Ok(existing) = serde_json::from_str::<VisualMeta>(json_part) {
                    if existing.id == meta.id {
                        out.push_str(&format!("{}{} -->\n", marker, serialized));
                        found = true;
                        continue;
                    }
                }
            }
        }
        out.push_str(line);
        out.push('\n');
    }

    if !found {
        out = format!("{}{} -->\n{}", marker, serialized, out);
    }

    out
}

/// Read all visual metadata comments from `content`.
pub fn read_all(content: &str) -> Vec<VisualMeta> {
    id_registry::clear();
    let mut metas = Vec::new();
    for json in comment_detector::extract_json(content) {
        if let Ok(mut meta) = serde_json::from_str::<VisualMeta>(&json) {
            migrate(&mut meta);
            id_registry::register(meta.clone());
            metas.push(meta);
        }
    }
    metas
}

/// Remove all visual metadata comments from `content`.
pub fn remove_all(content: &str) -> String {
    comment_detector::strip(content)
}

/// Convenience wrapper returning all visual metadata entries from `content`.
pub fn list(content: &str) -> Vec<VisualMeta> {
    read_all(content)
}

/// Fix issues in metadata comments, such as duplicate identifiers.
///
/// When duplicate ids are found, new unique ones are generated and the
/// updated metadata comments are reinserted into the document.
pub fn fix_all(content: &str) -> String {
    let mut metas = read_all(content);
    let mut seen = HashSet::new();
    let mut changed = false;
    for meta in &mut metas {
        if !seen.insert(meta.id.clone()) {
            meta.id = unique_id();
            changed = true;
        }
    }

    if !changed {
        return content.to_string();
    }

    let mut out = remove_all(content);
    for meta in &metas {
        out = upsert(&out, meta);
    }
    out
}

fn unique_id() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    format!("m{}", nanos)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use chrono::Utc;
    use serde_json::json;

    #[test]
    fn upsert_and_read_roundtrip() {
        let meta = VisualMeta {
            version: 1,
            id: "1".into(),
            x: 10.0,
            y: 20.0,
            tags: vec!["alpha".into(), "beta".into()],
            links: vec![],
            origin: None,
            translations: HashMap::new(),
            ai: Some(AiNote {
                description: Some("desc".into()),
                hints: vec!["hint".into()],
            }),
            extras: Some(json!({"foo": "bar"})),
            updated_at: Utc::now(),
        };
        let content = "fn main() {}";
        let updated = upsert(content, &meta);
        assert!(updated.contains(MARKER));
        let metas = read_all(&updated);
        assert_eq!(metas.len(), 1);
        assert_eq!(metas[0].x, 10.0);
        assert_eq!(metas[0].tags, vec!["alpha", "beta"]);
        assert!(metas[0].links.is_empty());
        assert_eq!(
            metas[0].ai.as_ref().unwrap().description.as_deref(),
            Some("desc")
        );
        assert_eq!(metas[0].extras, Some(json!({"foo": "bar"})));
        assert!(metas[0].updated_at.timestamp() > 0);
        assert_eq!(metas[0].version, 1);
    }

    #[test]
    fn remove_all_strips_metadata() {
        let content = format!("line1\n<!-- {} {{\"id\":\"1\"}} -->\nline2\n", MARKER);
        let cleaned = remove_all(&content);
        assert!(!cleaned.contains(MARKER));
        assert!(cleaned.contains("line1"));
        assert!(cleaned.contains("line2"));
    }

    #[test]
    fn fix_all_replaces_duplicate_ids() {
        let content = format!(
            "<!-- {} {{\"id\":\"1\",\"x\":0.0,\"y\":0.0}} -->\n<!-- {} {{\"id\":\"1\",\"x\":1.0,\"y\":1.0}} -->",
            MARKER, MARKER
        );
        let fixed = fix_all(&content);
        let metas = read_all(&fixed);
        assert_eq!(metas.len(), 2);
        assert_ne!(metas[0].id, metas[1].id);
    }
}
